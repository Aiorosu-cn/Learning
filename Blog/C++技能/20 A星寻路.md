[TOC]

# 原理

`open list`存放下一步可能会走的点也有可能不走的点,并把A点设置为周围点的父节点

和广度的区别是,会选F值最小的点走下一步

`close list`存放已经走过的点

`open`和 `close`都是一种状态,不一定是一个表,但是需要一个容器保存,方便排序

A星和广度的不同

`F值`,是综合评价这个点好不好的数值,由G和H组成,代价越小越好

G=起点到当前点的代价

H=现在的点到终点的代价

G是确定的,

H是估算的,包括了:

- 曼哈顿算法:只算水平和竖直相加
- 欧式算法:算两点坐标的几何距离
- 契比雪夫算法:函数要复杂点,自己查看

注意,算法只包括H,G是确定的

G一般用10和14来表示

# 工程实现

> 检查周围的点并将可以加入到openlist中的点加入进去
>
> 计算接的的FGH值
>
> 包含List
>
> 节点中加入FGH变量
>
> 状态中添加open和close状态
>
> 每次要找最小的F值,那么在open中排个序找最小的,方法最简单,所以还是需要个List
>
> 将起点状态改为open并压入openlist中
>
> 循环判断openlist是否为空或者已经找到终点
>
> > 从Openlist中取出F值最小的点并考察该点周围的点的情况
> >
> > 将front节点取出(F值已经是最小了),并从openlist中删除,改变为close状态;
> >
> > 从当前点周围还没加入Openlist的点加入openlist;

寻路方法上,需要思考可能的下一点的状态:

1. 终点

2. 可以走还没走:

3. 可以走但是已经作为open节点

> 如果已经在openlist中,检查这条路径(经由当前节点达到的路径)是否比已经存在的路径的F值更好,更小.如果是那么需要重新指定当前点为父节点(选择了更好的路径)
>
> 复制一份当前的数据进行假设性的计算,因为H值一样,只需要比较G值就行了

3. 是不能走的点

> 不需要做操作

4. 已经close的点;

> 不需要做操作

如果找到了终点,可以通过终点回溯路径得到最终的全部路径

## 计算FGH

得到父节点

判断移动到这个节点的耗费G值是多少

需要在类私有变量中记录一下起点和终点

> 曼哈顿算法:计算H值为 横竖距离 *10 ,估计的值
>
> 欧式距离,直接算距离,更
