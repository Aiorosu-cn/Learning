[TOC]

# 进程通讯

每个进程有自己独立的堆栈

进程之间通信的情况很多，比如服务器和客户端，比如外挂

进程之间通信包括：管道，网络

> 管道（pipe）是Unix/Linux中最常见的进程间通信方式之一，它在两个进程之间实现一个数据流通的通道，数据以一种数据流的方式在进程间流动。在系统中，管道相当于文件系统上的一个文件，用于缓存所要传输的数据。在某些特性上又不同于文件，例如当数据读出后，管道中就没有数据了，但文件没有这个特性。



# 线程通讯

进程的公共数据，线程都可以访问，但是每个线程也都有自己的栈区，这个只能自己访问。CPU其实是通过线程来调度进程的，

> 有一种方法可以提高程序的运行速度，就是增加线程，这样整个程序相对占用的线程就多，CPU资源就多，代价是CPU的功耗提高

## C++线程库

从C++ 11开始支持线程库，可以通过`std::this_thread::`来获取当前线程的对象

```cpp
#include <thread>//这就是C++11标准库中的线程库

int main()
{
    std::cout << "所属的线程ID：" << std::this_thread::get_id() <<std::endl;
} 
```

就算是同一个程序，每次运行都会重新开一个线程，和一个新ID

> 以前C++ 11没有线程库时，需要加载windows的线程库，需要用beginthread，或者freadThread来创建管理线程

## 线程对象

C++里把线程当做一个对象，创建线程对象时：

- 构造函数可以没有参数，调用**默认构造函数**会创建一个空的`std::thread` 执行对象
- 如果有参数，调用构造函数`explicit thread(Fn&& fn, Args&&... args)`，禁止隐式转换：
  - 新产生的线程会调用 `fn` 函数，
  - `fn`函数不能够传入引用类型（但是可以传指针），那样会出现两个线程访问到一样的东西（两个变量中其中一个有引用都不行）。

两个线程一定不能混合在一个地方输出

```cpp
#include <thread>

void Test0()//没有参数
{
    std::cout << "所属的线程ID：" << std::this_thread::get_id() <<std::endl;
    for(int i = 0 ; i < 100 ,++i)
    {
        std::cout << "id：" << std::this_thread::get_id() <<std::endl;
	}
} 

int main()
{
    std::cout << "所属的线程ID：" << std::this_thread::get_id() <<std::endl;
    
    //创建一个线程对象 test0，参数填写函数，这里创建了一个没有参数的回调函数
    std::thread test0(Test0);
    
    for(int i = 0 ; i < 100 ,++i)
    {
        std::cout << "id：" << std::this_thread::get_id() <<std::endl;
	}
    system("pause");
    return 0;
} 
```

上面的代码表示，创建线程，包括新线程的执行，和主线程完全没有关系，可能会出现：

- 主线程都快跑完了，子线程才开始创建。
- 主线程还没开始，子线程已经结束了；

虽然代码是从上往下执行，但是原始多线程的执行是无序的，包括向屏幕输出，可能也是两个线程分别各自输出字符，导致屏幕乱码。

> 当因为主线程已经 return 0 ，子线程还在跑，就会报错
>
> 这时候需要告诉子线程自己管自己，或者告诉主线程子线程需要结束自己才能结束
>

如果创建出来的对象没有说明运行方式，如果父线程退出的时候，子线程还没结束可能会出现问题

# 线程的运行模式

## 分离线程 detach

将子线程和父线程进行剥离，父线程结束的时候，子线程会自己回收结束而不是报错。

```cpp
int main()
{
    std::cout << "所属的线程ID：" << std::this_thread::get_id() <<std::endl;
    
    std::thread test0(Test0);//创建了一个线程对象，无参无返回值
    test0.detach();// <-----------------------------
    
    for(int i = 0 ; i < 1-- ,++i)
    {
        std::cout << "id：" << std::this_thread::get_id() <<std::endl;
	}
} 
```

使用detach要注意线程同步的问题，否则容易出错

## 结合线程 join

父线程运行到生成子线程时，会让子线程运行，等所有子线程结束以后，父线程再继续执行。

如果有多个子线程，每个子线程之间还是相互独立运行的。

执行之前，要先检查下子线程是否结束，需要先判断一下。

> 应用场景：等到所有子线程结束后，汇总结果给父线程

```cpp
//test.joinable();先判断能否jion
int main()
{
    std::cout << "所属的线程ID：" << std::this_thread::get_id() <<std::endl;
    
    std::thread test0(Test0);
    if(test0.joinable()//先判断能否jion)
    {
        test0.join();// <-----------------------------
    }  
    for(int i = 0 ; i < 1-- ,++i)
    {
        std::cout << "id：" << std::this_thread::get_id() <<std::endl;
	}
} 
```



# 线程池技术

程序先把线程开起来挂在那里不动，等有任务来了找个线程接待一下。

> 可以在任务管理器中的详细信息中，查看每个程序开的线程数量

# 协程

协程还是在单一的线程里面，不是一个多线程的东西。当程序进程运行到某个位置，把东西暂时存在协程离，然后执行其他的程序，下一次回来在继续执行。

协程看起来和异步类似，你执行一段我执行一段分开执行。