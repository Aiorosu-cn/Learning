[TOC]

# Actor通讯的4种方案

## 1. 直接通讯

直接Actor（Direct Actor）通信是关卡中各Actor间最常用的通信方法。

这种方法需要你引用目标Actor（target actor），以便当前Actor（working actor）获取目标Actor的信息。采用这类通信时，当前Actor和目标Actor之间是一对一的关系。

### 使用时机

如果你引用了关卡中的某个Actor，并且需要共享信息或触发该Actor的函数，则可以使用此通信方法。

## 2. 类型转换

类型转换是一种常用的通信方法，方法是获取Actor的引用，并尝试将其转换为其他类型。如果转换成功，则可以通过[直接通信](https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ActorCommunication/ActorCommunication-BP#直接通信)来访问其信息和功能。

此方法要求引用关卡中的Actor，以便使用 **Cast** 节点来将它转换成特定的类。采用此通信方法时，当前Actor和目标Actor之间是一对一关系。

### 使用时机

如果你已经引用了某个Actor，并且希望在访问其信息之前检查该Actor是否属于某个类型，请使用此通信方法。

## 3. 接口

接口会定义一组常用行为或功能，这些行为或功能可以由不同的Actor类实现。此通信方法简化了在不同Actor类上实现同类型函数的过程。

此方法要求每个Actor都实现接口，以便访问它们共有的函数。此外，你还需要拥有Actor的引用，以便通过引用来调用接口函数。采用这种通信方法时，当前Actor和目标Actor之间是一对一关系。

### 使用时机

当你希望为不同类型的Actor创建通用功能时，请使用此方法。

## 4. 事件分发器

采用事件分发器时，当某个Actor触发事件后，所有其他监听该事件的Actor都会收到通知。

此方法要求在当前Actor上创建事件分发器（Event Dispatche），并将目标Actor绑定给这些分发器。此通信方法使用一对多关系，其中单个Actor负责触发多个监听Actor的事件分发器。

### 使用时机

如果想要让单个事件影响多个不同Actor，可以使用此通信方法。



# 为什么需要事件通讯

当达到一定条件,比如按下某个按键,受到一次碰撞,就会触发一次事件/函数,是常用的方法

> 如果想在Actor中添加按键事件,会发现没有效果,因为Actror无法接受输入,本身不支持接受按键事件.这就需要事件通讯; 



# 事件通讯的场景

## 使用输入事件

- 在input 下开启接受输入但是这种方式,如果有多个actor,只有最后一个能接受输入;
- 在Actor中的按键事件中,关闭销毁输入;
- UE里面的输入首先传给actor-场景-pawn;

| Auto Receive input | actor-inpu  | 接受玩家的输入               |
| ------------------ | ----------- | ---------------------------- |
| Consume Input      | actor-input | 我之后其他人不要处理这个事件 |



## 调用自己的自定义事件

- 场景中添加自定义事件
- 使用**`call`**直接调用事件

| custom event | 自定义事件 | 可以把自定事件看做没有参数和返回值的函数 |
| ------------ | ---------- | ---------------------------------------- |



## 执行其他蓝图的事件

### CE控制台命令

>  在游戏中,使用`~`可以调用控制台命令,
>
> 也可以通过一个按键调用控制台命令节点,执行通关的事件

- 在蓝图A中自定义一个事件
- 在蓝图B中用一个输入事件触发控制台命令节点,命令就是触发蓝图A中的自定义事件;

| 节点名字                | 类       | 节点说明                                                     |
| ----------------------- | -------- | ------------------------------------------------------------ |
| execute console command | 开发者   | 参数中使用 ce + 场景事件名字执行任何事件<br />参数中使用 ke + 类型名 + 类中事件名字执行任何事件<br />相当于向同样类型中广播事件 |
| get class               | 公共程序 | 获取类的信息                                                 |
| get display name        | 公共程序 | 获取对象名字,对象可以是类,可以是实例                         |

缺点:过于作弊,只能作为调试或者后台使用

效率有牺牲

### 事件分发器

事件分发器Event Dispatchers工作机制是:发报机公开出来后,可以接受别人往分发器绑定事件

- Actor A中创建一个事件分发器,并注册一个事件到分发器中;
- Actor B中可以调出A的事件到分发器,只需要Target参数是A就行;
- B中把B的自定义事件注册到A的事件分发器;
- C中通过call event dispatchers,Target参数是A,会调用该发报机中绑定的所有事件

按照注册的顺序来执行事件

> 事件分发器的用法之一,做一个类似触发器的东西,一旦触发就调用发报机.
>
> 然后把门,烟火,特效等事件都绑在这个发报机上,一旦触发,就能全都触发
>
> 一般可用于通关时-一边打开关卡,一边放烟花,一边弹出UI这种同时需要触发多个事件的地方

**bind 时 Creat  event 和 自定义事件的区别**

可以传入对象的公开函数

| Bind Event to XXX         | Default           | 向发报机注册事件,可以是类中,也可以是其他类中 |
| ------------------------- | ----------------- | -------------------------------------------- |
| Format text               | 格式化文字        | 花括号括起来的东西当做变量,返回一个string    |
| call event 事件分发器名字 | Default           | 让事件分发器按顺序执行注册的事件             |
| Creat event               | Event Dispatchers | 允许调用对象中的公开方法                     |

#### 分发器的创建和使用

在Actor 1下的 **event dispatchers** 下创建一个事件分发器,然后拖到**事件视图**中,会出现6种类型

| 函数        | 函数作用                                                     |
| ----------- | ------------------------------------------------------------ |
| unbind from | 将具体某一事件从发报机中取消掉,最好在哪注册,就在哪取消       |
| unbind All  | 不管场景中注册了什么全没有事件                               |
| Event       | 自动创建事件,和自动创建自定义事件没有区别,甚至不会自动关联到发报机 |
| Assign      | 帮你创建自定义事件,并且bind到事件分发器中,本质和Bind没有区别 |
| call        | 执行发报机,会执行发报机下所有bind的函数                      |
| Bind        | Bind Event to 节点,往发报机中注册事件                        |

#### 往发报机中注册事件

- 在其他蓝图中,获取Actor 1类型,可以使用函数**`Bind Event to 发报机名字`**注册事件

- 在Actor 1中可以直接拖动发报机,然后选择`Bind` ;

#### 事件执行顺序

事件按照发报机



#### 分发器的作用

- 在游戏中创建BossDied事件。当有敌人Boss死掉时，此事件将会触发，导致门Actor打开，HUD Actor会显示一条消息，且宝箱Actor打开。
- 创建一个日夜循环，其中的DayStarted事件负责通知NPC开始每天的例行活动。
